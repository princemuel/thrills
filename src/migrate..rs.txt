use std::fs;
use std::path::PathBuf;

fn main() -> std::io::Result<()> {
    fs::read_dir(".")?
        .filter_map(Result::ok)
        .filter_map(|e| {
            let path = e.path();
            match path.extension()?.to_str()? {
                "py" => Some((path.file_stem()?.to_string_lossy().into_owned(), true)),
                "rs" => Some((path.file_stem()?.to_string_lossy().into_owned(), false)),
                _ => None,
            }
        })
        .fold(
            std::collections::HashMap::<String, (Option<PathBuf>, Option<PathBuf>)>::new(),
            |mut acc, (stem, is_py)| {
                let entry = acc.entry(stem.clone()).or_default();
                let path = if is_py {
                    PathBuf::from(format!("{}.py", stem))
                } else {
                    PathBuf::from(format!("{}.rs", stem))
                };
                if is_py { entry.0 = Some(path); } else { entry.1 = Some(path); }
                acc
            },
        )
        .into_iter()
        .filter_map(|(stem, (py, rs))| Some((stem, py?, rs?)))
        .try_for_each(|(stem, py_path, rs_path)| {
            fs::create_dir_all(&stem)?;
            fs::rename(py_path, format!("{}/main.py", stem))?;
            fs::rename(rs_path, format!("{}/main.rs", stem))?;
            println!("Created {stem}/ with main.py and main.rs");
            Ok(())
        })?;

    println!("Done!");
    Ok(())
}


use std::fs;
use std::path::Path;
use std::collections::HashSet;

fn main() -> std::io::Result<()> {
    // Read current directory
    let entries = fs::read_dir(".")?;

    // Collect all basenames that have both .py and .rs files
    let mut py_files = HashSet::new();
    let mut rs_files = HashSet::new();

    for entry in entries {
        let entry = entry?;
        let path = entry.path();

        if let Some(ext) = path.extension() {
            if let Some(stem) = path.file_stem() {
                let stem_str = stem.to_string_lossy().to_string();

                match ext.to_str() {
                    Some("py") => { py_files.insert(stem_str); }
                    Some("rs") => { rs_files.insert(stem_str); }
                    _ => {}
                }
            }
        }
    }

    // Find intersection - files that exist in both sets
    let paired_files: Vec<_> = py_files.intersection(&rs_files).collect();

    // Process each pair
    for basename in paired_files {
        let dir_path = Path::new(basename);
        let py_src = format!("{}.py", basename);
        let rs_src = format!("{}.rs", basename);
        let py_dst = dir_path.join("main.py");
        let rs_dst = dir_path.join("main.rs");

        // Create directory
        fs::create_dir_all(dir_path)?;

        // Move files
        fs::rename(&py_src, &py_dst)?;
        fs::rename(&rs_src, &rs_dst)?;

        println!("Created {}/ with main.py and main.rs", basename);
    }

    println!("Done!");
    Ok(())
}
